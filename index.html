<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Lo siento mucho</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="styles.css" rel="stylesheet" />
  <meta name="description" content="Un espacio sincero para pedir perdón y comprometer cambios reales." />
</head>
<body>
  <main class="container" id="app">
    <section class="hero" aria-labelledby="h1">
      <h1 id="h1" class="sr-only">Lo siento mucho</h1>
      <div id="heroLine" class="typewriter" aria-live="polite"></div>
      <p id="heroSub" class="hero-sub"></p>
      <span class="heart" aria-hidden="true"></span>
    </section>

    <section class="cards" id="cards" aria-label="Razones y compromisos"></section>

    <section class="commitments" id="commitmentsSection" aria-labelledby="commitTitle">
      <h2 id="commitTitle">Mis compromisos</h2>
      <div id="ckList" class="ck-list"></div>
      <div class="progress">
        <progress id="prog" max="0" value="0" aria-label="Progreso compromisos"></progress>
        <span id="progText">0/0</span>
      </div>
      <button id="cta" class="cta" type="button"></button>
    </section>
  </main>

  <script>
    // ========================
    // CONFIGURACIÓN EDITABLE
    // Modifica SOLO este objeto para cambiar todo el texto.
    // ========================
    const CONFIG = {
      heroLine: "¿Podrías darme otra oportunidad?",
      heroSub: "Desde lo más sincero de mi corazón, y aceptando todas las condiciones y límites que me impongas, quiero reparar cada error que he cometido con hechos, no con palabras.",
      cards: [
        { front: "Tus condiciones primero", back: "Acepto límites, pruebas y tiempos como tu lo veas conveniente para tomar una decision, sin excepciones." },
        { front: "Transparencia total", back: "Verdad completa y a tiempo, nada quedará oculto o silenciado, todo estará siempre claro para evitar conflictos." },
        { front: "Escuchar y calma", back: "Pausar, pensar, no habrá lugar para rabia, enojos o conclusiones apuradas." },
        { front: "Fe y familia", back: "Recordar y honrar lo aprendido: corregir a tiempo y caminar en lo correcto, juntos." }
      ],
      commitments: [
        "Cumplir cada condición que establezcas, sin excusas ni atajos.",
        "Ser transparente en todo momento, sin excepciones.",
        "Escuchar de verdad, bajar la intensidad y hablar con calma.",
        "Buscar tu ayuda y tu opinión para no repetir errores.",
        "Respetar tus tiempos y tu espacio; puedes decidir en cuanto lo veas viable.",
        "Usar cada día y la fuerza que Dios me da para demostrarte cambios realistas y sinceros."
      ],
      ctaText: "Espero que puedas comprender todo lo que te expreso, he usado todo lo aprendido para expresarte mis sentimientos :'(",
      ctaAlert: "Gracias por tomarte el tiempo de revisarlo. ¿Podrias considerar mi propuesta? :'(",
      typingDurationMs: 3400
    };

    // ========================
    // UTILIDADES DOM (DRY)
    // ========================
    const DOM = {
      qs: (sel, el = document) => el.querySelector(sel),
      qsa: (sel, el = document) => Array.from(el.querySelectorAll(sel)),
      createElement: (tag, className = '', content = '') => {
        const el = document.createElement(tag);
        if (className) el.className = className;
        if (content) el.textContent = content;
        return el;
      }
    };

    // ========================
    // RENDERIZADOR HERO (SRP)
    // ========================
    class HeroRenderer {
      static render(config) {
        const heroLine = DOM.qs('#heroLine');
        const heroSub = DOM.qs('#heroSub');
        const heart = DOM.qs('.heart');
        
        heroLine.textContent = config.heroLine;
        heroLine.style.setProperty('--steps', String(config.heroLine.length || 30));
        heroLine.style.setProperty('--typing-duration', `${config.typingDurationMs || 3000}ms`);
        heroSub.textContent = config.heroSub;
        
        // Configurar corazón interactivo
        this.setupHeartInteraction(heart);
      }

      static setupHeartInteraction(heartElement) {
        // Hacer el corazón clickeable
        heartElement.style.cursor = 'pointer';
        heartElement.setAttribute('role', 'button');
        heartElement.setAttribute('tabindex', '0');
        heartElement.setAttribute('aria-label', 'Toca para ver una sorpresa');
        
        // Evento de click
        heartElement.addEventListener('click', () => {
          VideoManager.showVideo();
        });
        
        // Evento de teclado
        heartElement.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            VideoManager.showVideo();
          }
        });
        
        // Tooltip
        TooltipManager.bindTooltipEvents(heartElement, 'Toca para ver una sorpresa ❤️');
      }
    }

    // ========================
    // RENDERIZADOR CARDS (SRP)
    // ========================
    class CardRenderer {
      static createCard({ front, back }, index) {
        const card = DOM.createElement('div', 'card');
        card.tabIndex = 0;
        card.setAttribute('aria-label', `${front}. Click para ver más información`);
        card.setAttribute('role', 'button');
        
        card.innerHTML = `
          <div class="card-content">
            <h3>${front}</h3>
            <div class="card-hint">Toca para ver más</div>
          </div>
        `;
        
        // Evento de click/touch
        card.addEventListener('click', () => {
          ModalManager.show(front, back);
        });
        
        // Evento de teclado para accesibilidad
        card.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            card.click();
          }
        });
        
        return card;
      }

      static render(cards) {
        const container = DOM.qs('#cards');
        container.innerHTML = '';
        cards.forEach((card, index) => container.appendChild(this.createCard(card, index)));
      }
    }

    // ========================
    // RENDERIZADOR COMPROMISOS (SRP)
    // ========================
    class CommitmentsRenderer {
      static createCommitmentItem(text, index) {
        const id = `c_${index + 1}`;
        const label = DOM.createElement('label', 'ck-item');
        
        label.innerHTML = `
          <input type="checkbox" id="${id}" data-key="${id}" />
          <span>${text}</span>
        `;
        
        return label;
      }

      static render(commitments, ctaText, ctaAlert) {
        const list = DOM.qs('#ckList');
        const progress = DOM.qs('#prog');
        const progressText = DOM.qs('#progText');
        const ctaButton = DOM.qs('#cta');
        
        // Limpiar y renderizar lista
        list.innerHTML = '';
        commitments.forEach((text, i) => {
          list.appendChild(this.createCommitmentItem(text, i));
        });
        
        // Configurar progreso
        progress.max = commitments.length;
        progressText.textContent = `0/${commitments.length}`;
        
        // Configurar CTA
        ctaButton.textContent = ctaText;
        ctaButton.addEventListener('click', () => {
          alert(ctaAlert);
          WhatsAppManager.redirectToWhatsApp();
        });
      }
    }

    // ========================
    // GESTOR DE ESTADO (SRP)
    // ========================
    class StateManager {
      static STORAGE_PREFIX = 'apology_';

      static loadState() {
        DOM.qsa('.ck-list input[type="checkbox"]').forEach(checkbox => {
          const value = localStorage.getItem(this.STORAGE_PREFIX + checkbox.dataset.key);
          if (value === '1') checkbox.checked = true;
        });
        this.updateProgress();
      }

      static updateProgress() {
        const checkboxes = DOM.qsa('.ck-list input[type="checkbox"]');
        const completed = checkboxes.filter(cb => cb.checked).length;
        
        DOM.qs('#prog').value = completed;
        DOM.qs('#progText').textContent = `${completed}/${checkboxes.length}`;
      }

      static bindCommitments() {
        DOM.qsa('.ck-list input[type="checkbox"]').forEach(checkbox => {
          checkbox.addEventListener('change', () => {
            const key = this.STORAGE_PREFIX + checkbox.dataset.key;
            localStorage.setItem(key, checkbox.checked ? '1' : '0');
            this.updateProgress();
          });
        });
      }
    }

    // ========================
    // GESTOR DE MODALES (SRP)
    // ========================
    class ModalManager {
      static createModal() {
        const modal = DOM.createElement('div', 'modal-overlay');
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-hidden', 'true');
        
        modal.innerHTML = `
          <div class="modal-content">
            <div class="modal-header">
              <h2 class="modal-title"></h2>
              <button class="modal-close" aria-label="Cerrar">&times;</button>
            </div>
            <div class="modal-body">
              <p class="modal-message"></p>
            </div>
            <div class="modal-footer">
              <button class="modal-btn modal-btn-primary">Entendido</button>
            </div>
          </div>
        `;
        
        return modal;
      }

      static show(title, message) {
        // Crear modal si no existe
        let modal = DOM.qs('.modal-overlay');
        if (!modal) {
          modal = this.createModal();
          document.body.appendChild(modal);
        }
        
        // Configurar contenido
        DOM.qs('.modal-title', modal).textContent = title;
        DOM.qs('.modal-message', modal).textContent = message;
        
        // Mostrar modal
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.add('active');
        document.body.classList.add('modal-open');
        
        // Enfocar el botón de cerrar
        DOM.qs('.modal-close', modal).focus();
        
        // Eventos de cierre
        this.bindCloseEvents(modal);
      }

      static hide(modal) {
        modal.setAttribute('aria-hidden', 'true');
        modal.classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      static bindCloseEvents(modal) {
        const closeBtn = DOM.qs('.modal-close', modal);
        const primaryBtn = DOM.qs('.modal-btn-primary', modal);
        const overlay = modal;
        
        const closeModal = () => this.hide(modal);
        
        closeBtn.addEventListener('click', closeModal);
        primaryBtn.addEventListener('click', closeModal);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) closeModal();
        });
        
        // Cerrar con Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
      }
    }

    // ========================
    // GESTOR DE TOOLTIP (SRP)
    // ========================
    class TooltipManager {
      static createTooltip(text, targetElement) {
        const tooltip = DOM.createElement('div', 'tooltip');
        tooltip.textContent = text;
        tooltip.setAttribute('role', 'tooltip');
        tooltip.setAttribute('aria-hidden', 'true');
        
        // Posicionar tooltip
        const rect = targetElement.getBoundingClientRect();
        tooltip.style.position = 'absolute';
        tooltip.style.top = `${rect.top - 40}px`;
        tooltip.style.left = `${rect.left + (rect.width / 2)}px`;
        tooltip.style.transform = 'translateX(-50%)';
        
        return tooltip;
      }

      static showTooltip(text, targetElement) {
        this.hideTooltip(); // Limpiar tooltip existente
        
        const tooltip = this.createTooltip(text, targetElement);
        document.body.appendChild(tooltip);
        
        // Mostrar con delay para evitar spam
        setTimeout(() => {
          if (tooltip.parentNode) {
            tooltip.classList.add('active');
            tooltip.setAttribute('aria-hidden', 'false');
          }
        }, 100);
        
        return tooltip;
      }

      static hideTooltip() {
        const existingTooltip = DOM.qs('.tooltip');
        if (existingTooltip) {
          existingTooltip.remove();
        }
      }

      static bindTooltipEvents(element, text) {
        let tooltipTimeout;
        
        element.addEventListener('mouseenter', () => {
          tooltipTimeout = setTimeout(() => {
            this.showTooltip(text, element);
          }, 500); // Delay de 500ms
        });
        
        element.addEventListener('mouseleave', () => {
          clearTimeout(tooltipTimeout);
          this.hideTooltip();
        });
        
        element.addEventListener('focus', () => {
          this.showTooltip(text, element);
        });
        
        element.addEventListener('blur', () => {
          this.hideTooltip();
        });
      }
    }

    // ========================
    // GESTOR DE VIDEO (SRP)
    // ========================
    class VideoManager {
      static VIDEO_PATH = 'files/video.mp4';
      static VIDEO_CONFIG = {
        width: 720,
        height: 720,
        duration: 38.42,
        aspectRatio: '1:1'
      };

      static createVideoModal() {
        const modal = DOM.createElement('div', 'video-modal-overlay');
        modal.setAttribute('role', 'dialog');
        modal.setAttribute('aria-modal', 'true');
        modal.setAttribute('aria-hidden', 'true');
        modal.setAttribute('aria-label', 'Reproductor de video sorpresa');
        
        modal.innerHTML = `
          <div class="video-modal-content">
            <div class="video-modal-header">
              <h2 class="video-modal-title">Una sorpresa para ti ❤️</h2>
              <button class="video-modal-close" aria-label="Cerrar video">&times;</button>
            </div>
            <div class="video-modal-body">
              <video class="video-player" controls preload="metadata" aria-label="Video sorpresa">
                <source src="${this.VIDEO_PATH}" type="video/mp4">
                Tu navegador no soporta la reproducción de video.
              </video>
            </div>
            <div class="video-modal-footer">
              <!-- Footer vacío - solo se usa el botón X del header -->
            </div>
          </div>
        `;
        
        return modal;
      }

      static showVideo() {
        let modal = DOM.qs('.video-modal-overlay');
        if (!modal) {
          modal = this.createVideoModal();
          document.body.appendChild(modal);
        }
        
        // Mostrar modal
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.add('active');
        document.body.classList.add('video-modal-open');
        
        // Enfocar el botón de cerrar
        DOM.qs('.video-modal-close', modal).focus();
        
        // Eventos de cierre
        this.bindVideoCloseEvents(modal);
      }

      static hideVideo(modal) {
        const video = DOM.qs('.video-player', modal);
        if (video) {
          video.pause();
          video.currentTime = 0;
        }
        
        modal.setAttribute('aria-hidden', 'true');
        modal.classList.remove('active');
        document.body.classList.remove('video-modal-open');
      }

      static bindVideoCloseEvents(modal) {
        const closeBtn = DOM.qs('.video-modal-close', modal);
        const overlay = modal;
        
        const closeVideo = () => this.hideVideo(modal);
        
        closeBtn.addEventListener('click', closeVideo);
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) closeVideo();
        });
        
        // Cerrar con Escape
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeVideo();
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
      }
    }

    // ========================
    // GESTOR DE WHATSAPP (SRP)
    // ========================
    class WhatsAppManager {
      static PHONE_NUMBER = '+593993686769';
      static DEFAULT_MESSAGE = 'Hablemos';

      static generateWhatsAppURL(phoneNumber = this.PHONE_NUMBER, message = this.DEFAULT_MESSAGE) {
        const encodedMessage = encodeURIComponent(message);
        const cleanPhoneNumber = phoneNumber.replace(/[^\d+]/g, '');
        return `https://wa.me/${cleanPhoneNumber}?text=${encodedMessage}`;
      }

      static redirectToWhatsApp(phoneNumber = this.PHONE_NUMBER, message = this.DEFAULT_MESSAGE) {
        const url = this.generateWhatsAppURL(phoneNumber, message);
        window.open(url, '_blank');
      }
    }

    // ========================
    // CONTROLADOR PRINCIPAL (SRP)
    // ========================
    class AppController {
      static initialize() {
        this.setupAccessibility();
        this.render();
        this.bindEvents();
      }

      static setupAccessibility() {
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReducedMotion) {
          document.documentElement.classList.add('reduced-motion');
        }
      }

      static render() {
        HeroRenderer.render(CONFIG);
        CardRenderer.render(CONFIG.cards);
        CommitmentsRenderer.render(CONFIG.commitments, CONFIG.ctaText, CONFIG.ctaAlert);
      }

      static bindEvents() {
        StateManager.loadState();
        StateManager.bindCommitments();
      }
    }

    // ========================
    // INICIALIZACIÓN
    // ========================
    document.addEventListener('DOMContentLoaded', () => AppController.initialize());
  </script>
</body>
</html>
